Submission counter: 0 << Keep track of your submission counts

Student ID:

Statement
---------
1.UnorderedMap.java 中put函数中向Claude询问处理冲突的方法，Claude提供了线性探测的方法。
# 实现线性探测：
while (currentSlot != null) {
    if (currentSlot.key.equals(key)) {
        // 找到了，替换
    }
    index = (index + 1) % this.capacity;  // 移到下一个位置
    currentSlot = this.data[index];
}
2.claude 推荐多项式滚动哈希的方法实现bucketIndex函数
/**
 * 多项式滚动哈希
 * 简单且效果好
 */
private int bucketIndex(K key) {
    if (key == null) {
        return 0;
    }
    
    String keyString = key.toString();
    int hash = 0;
    
    // 使用31作为乘数
    for (int i = 0; i < keyString.length(); i++) {
        hash = 31 * hash + keyString.charAt(i);
    }
    
    // 处理负数：如果是负数就取绝对值
    if (hash < 0) {
        hash = -hash;
    }
    
    int index = hash % this.capacity;
    return index;
}
3.源代码：
    // OrderedMap specific functionality; this is why we need ordered maps
    // and not just maps.
    
    /** Returns the value associated with the smallest key greater than or
     * equal to `key`
     */
    public V nextGeq(K key) {
        // Implement me!
        ArrayList<K> allKeys = new ArrayList<>();
        inOrderTraversal(root, allKeys);
        
        for (K k : allKeys) {
            if (k.compareTo(key) >= 0) {
                return get(k);
            }
        }
        return null;
    }

    /** Returns the value associated with the largest key less than or
     * equal to `key`
     */
    public V nextLeq(K key) {
        // Implement me!
        ArrayList<K> allKeys = new ArrayList<>();
        inOrderTraversal(root, allKeys);
        
        for (int i = allKeys.size() - 1; i >= 0; i--) {
            K k = allKeys.get(i);
            if (k.compareTo(key) <= 0) {
                return get(k);
            }
        }
        return null;
    }


    /** Returns a SORTED list of keys in the range [lo, hi]*/
    public List<K> keysInRange(K lo, K hi) {
        ArrayList<K> allKeys = new ArrayList<>();
        // Implement me!
        inOrderTraversal(root, allKeys);
        
        ArrayList<K> keysInRange = new ArrayList<>();
        for (K key : allKeys) {
            if (key.compareTo(lo) >= 0 && key.compareTo(hi) <= 0) {
                keysInRange.add(key);
            }
            if (key.compareTo(hi) > 0) {
                break;
            }
        }
        return keysInRange;
    }
    private void inOrderTraversal(Node<K, V> node, ArrayList<K> keys) {
        if (node == null) {
            return;
        }
        
        inOrderTraversal(node.getLeft(), keys);
        keys.add(node.getKey());
        inOrderTraversal(node.getRight(), keys);
    }
借助Claude修改算法摈弃之前用中序遍历获取数组的方法，改用递归提高执行效率
/** Returns the value associated with the smallest key greater than or
 * equal to `key`
 */
public V nextGeq(K key) {
    Node<K, V> result = nextGeqHelper(root, key, null);
    return result == null ? null : result.getValue();
}

/**
 * 递归辅助方法：找到 >= key 的最小节点
 */
private Node<K, V> nextGeqHelper(Node<K, V> node, K key, Node<K, V> candidate) {
    if (node == null) {
        return candidate;
    }
    
    int cmp = key.compareTo(node.getKey());
    
    if (cmp == 0) {
        // 找到完全相等的，直接返回
        return node;
    } else if (cmp < 0) {
        // key < node.key，当前节点是候选，但左子树可能有更小的
        return nextGeqHelper(node.getLeft(), key, node);
    } else {
        // key > node.key，答案在右子树
        return nextGeqHelper(node.getRight(), key, candidate);
    }
}

/** Returns the value associated with the largest key less than or
 * equal to `key`
 */
public V nextLeq(K key) {
    Node<K, V> result = nextLeqHelper(root, key, null);
    return result == null ? null : result.getValue();
}

/**
 * 递归辅助方法：找到 <= key 的最大节点
 */
private Node<K, V> nextLeqHelper(Node<K, V> node, K key, Node<K, V> candidate) {
    if (node == null) {
        return candidate;
    }
    
    int cmp = key.compareTo(node.getKey());
    
    if (cmp == 0) {
        // 找到完全相等的，直接返回
        return node;
    } else if (cmp > 0) {
        // key > node.key，当前节点是候选，但右子树可能有更大的
        return nextLeqHelper(node.getRight(), key, node);
    } else {
        // key < node.key，答案在左子树
        return nextLeqHelper(node.getLeft(), key, candidate);
    }
}

/** Returns a SORTED list of keys in the range [lo, hi]*/
public List<K> keysInRange(K lo, K hi) {
    ArrayList<K> result = new ArrayList<>();
    keysInRangeHelper(root, lo, hi, result);
    return result;
}

/**
 * 递归辅助方法：收集范围内的key（中序遍历）
 */
private void keysInRangeHelper(Node<K, V> node, K lo, K hi, ArrayList<K> result) {
    if (node == null) {
        return;
    }
    
    int cmpLo = node.getKey().compareTo(lo);
    int cmpHi = node.getKey().compareTo(hi);
    
    // 如果当前节点 > lo，左子树可能有符合条件的
    if (cmpLo > 0) {
        keysInRangeHelper(node.getLeft(), lo, hi, result);
    }
    
    // 如果当前节点在范围内，添加
    if (cmpLo >= 0 && cmpHi <= 0) {
        result.add(node.getKey());
    }
    
    // 如果当前节点 < hi，右子树可能有符合条件的
    if (cmpHi < 0) {
        keysInRangeHelper(node.getRight(), lo, hi, result);
    }
}
```

## 性能对比

| 方法 | 树有10000个节点 | 执行时间 |
|------|----------------|---------|
| **中序遍历全部** | 遍历10000个节点 | ~5000ms ❌ |
| **递归优化** | 遍历~20个节点 | ~5ms ✅ |

## 为什么递归方法快这么多？

### 示例：树有1000个节点，查找 nextGeq(500)

**你的方法（中序遍历）：**
```
1. 遍历所有1000个节点 → 得到有序数组
2. 遍历数组找到第一个 >= 500 的
总计：访问1000个节点
```

**递归方法：**
```
1. 从根开始
2. 只访问路径上的节点（树高约10个节点）
3. 找到答案
总计：访问10个节点
Refer to the referencing guide on the LMS for details on what needs to go in
here. If in doubt, put your references here. Ignorance is NOT an excuse for
skipping this process.
