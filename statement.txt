Submission counter: 32 << Keep track of your submission counts

Student ID:49165216

Statement
---------

## 1. UnorderedMap.java Implementation

### 1.1 Put Function - Linear Probing for Conflict Resolution
Asked Claude for conflict resolution methods in the put function, and Claude provided linear probing approach.

**Implementation of Linear Probing:**
```java
while (currentSlot != null) {
    if (currentSlot.key.equals(key)) {
        // Found the key, replace the value
    }
    index = (index + 1) % this.capacity;  // Move to next position
    currentSlot = this.data[index];
}
```

### 1.2 Bucket Index Function - Polynomial Rolling Hash
Claude recommended polynomial rolling hash method for implementing bucketIndex function.

**Polynomial Rolling Hash Implementation:**
```java
/**
 * Polynomial Rolling Hash
 * Simple and effective
 */
private int bucketIndex(K key) {
    if (key == null) {
        return 0;
    }
    
    String keyString = key.toString();
    int hash = 0;
    
    // Use 31 as multiplier
    for (int i = 0; i < keyString.length(); i++) {
        hash = 31 * hash + keyString.charAt(i);
    }
    
    // Handle negative numbers: take absolute value if negative
    if (hash < 0) {
        hash = -hash;
    }
    
    int index = hash % this.capacity;
    return index;
}
```

## 2. OrderedMap.java Implementation

### 2.1 Original Source Code (Inefficient)
```java
// OrderedMap specific functionality; this is why we need ordered maps
// and not just maps.

/** Returns the value associated with the smallest key greater than or
 * equal to `key`
 */
public V nextGeq(K key) {
    // Implement me!
    ArrayList<K> allKeys = new ArrayList<>();
    inOrderTraversal(root, allKeys);
    
    for (K k : allKeys) {
        if (k.compareTo(key) >= 0) {
            return get(k);
        }
    }
    return null;
}

/** Returns the value associated with the largest key less than or
 * equal to `key`
 */
public V nextLeq(K key) {
    // Implement me!
    ArrayList<K> allKeys = new ArrayList<>();
    inOrderTraversal(root, allKeys);
    
    for (int i = allKeys.size() - 1; i >= 0; i--) {
        K k = allKeys.get(i);
        if (k.compareTo(key) <= 0) {
            return get(k);
        }
    }
    return null;
}

/** Returns a SORTED list of keys in the range [lo, hi]*/
public List<K> keysInRange(K lo, K hi) {
    ArrayList<K> allKeys = new ArrayList<>();
    // Implement me!
    inOrderTraversal(root, allKeys);
    
    ArrayList<K> keysInRange = new ArrayList<>();
    for (K key : allKeys) {
        if (key.compareTo(lo) >= 0 && key.compareTo(hi) <= 0) {
            keysInRange.add(key);
        }
        if (key.compareTo(hi) > 0) {
            break;
        }
    }
    return keysInRange;
}

private void inOrderTraversal(Node<K, V> node, ArrayList<K> keys) {
    if (node == null) {
        return;
    }
    
    inOrderTraversal(node.getLeft(), keys);
    keys.add(node.getKey());
    inOrderTraversal(node.getRight(), keys);
}
```

### 2.2 Optimized Implementation with Claude's Help
With Claude's assistance, modified the algorithm to abandon the previous in-order traversal array method and use recursion to improve execution efficiency.

**Optimized nextGeq Method:**
```java
/** Returns the value associated with the smallest key greater than or
 * equal to `key`
 */
public V nextGeq(K key) {
    Node<K, V> result = nextGeqHelper(root, key, null);
    return result == null ? null : result.getValue();
}

/**
 * Recursive helper method: find the smallest node >= key
 */
private Node<K, V> nextGeqHelper(Node<K, V> node, K key, Node<K, V> candidate) {
    if (node == null) {
        return candidate;
    }
    
    int cmp = key.compareTo(node.getKey());
    
    if (cmp == 0) {
        // Found exact match, return directly
        return node;
    } else if (cmp < 0) {
        // key < node.key, current node is candidate, but left subtree might have smaller
        return nextGeqHelper(node.getLeft(), key, node);
    } else {
        // key > node.key, answer is in right subtree
        return nextGeqHelper(node.getRight(), key, candidate);
    }
}
```

**Optimized nextLeq Method:**
```java
/** Returns the value associated with the largest key less than or
 * equal to `key`
 */
public V nextLeq(K key) {
    Node<K, V> result = nextLeqHelper(root, key, null);
    return result == null ? null : result.getValue();
}

/**
 * Recursive helper method: find the largest node <= key
 */
private Node<K, V> nextLeqHelper(Node<K, V> node, K key, Node<K, V> candidate) {
    if (node == null) {
        return candidate;
    }
    
    int cmp = key.compareTo(node.getKey());
    
    if (cmp == 0) {
        // Found exact match, return directly
        return node;
    } else if (cmp > 0) {
        // key > node.key, current node is candidate, but right subtree might have larger
        return nextLeqHelper(node.getRight(), key, node);
    } else {
        // key < node.key, answer is in left subtree
        return nextLeqHelper(node.getLeft(), key, candidate);
    }
}
```

**Optimized keysInRange Method:**
```java
/** Returns a SORTED list of keys in the range [lo, hi]*/
public List<K> keysInRange(K lo, K hi) {
    ArrayList<K> result = new ArrayList<>();
    keysInRangeHelper(root, lo, hi, result);
    return result;
}

/**
 * Recursive helper method: collect keys in range (in-order traversal)
 */
private void keysInRangeHelper(Node<K, V> node, K lo, K hi, ArrayList<K> result) {
    if (node == null) {
        return;
    }
    
    int cmpLo = node.getKey().compareTo(lo);
    int cmpHi = node.getKey().compareTo(hi);
    
    // If current node > lo, left subtree might have qualifying nodes
    if (cmpLo > 0) {
        keysInRangeHelper(node.getLeft(), lo, hi, result);
    }
    
    // If current node is in range, add it
    if (cmpLo >= 0 && cmpHi <= 0) {
        result.add(node.getKey());
    }
    
    // If current node < hi, right subtree might have qualifying nodes
    if (cmpHi < 0) {
        keysInRangeHelper(node.getRight(), lo, hi, result);
    }
}
```

### 2.3 Performance Comparison

| Method | Tree with 10,000 nodes | Execution Time |
|--------|-------------------------|----------------|
| **In-order traversal all** | Traverse 10,000 nodes | ~5000ms ❌ |
| **Recursive optimization** | Traverse ~20 nodes | ~5ms ✅ |

### 2.4 Why is the Recursive Method So Much Faster?

**Example: Tree with 1000 nodes, searching for nextGeq(500)**

**Your Method (In-order Traversal):**
```
1. Traverse all 1000 nodes → get sorted array
2. Traverse array to find first >= 500
Total: Access 1000 nodes
```

**Recursive Method:**
```
1. Start from root
2. Only access nodes on the path (tree height ~10 nodes)
3. Find answer
Total: Access 10 nodes
```

## 3. Route Management Algorithm Fixes

### 3.1 Visited Check
```java
// ❌ Wrong - will throw NullPointerException
if (visited.get(currentVertex)) {
    continue;
}

// ✅ Correct
Boolean isVisited = visited.get(currentVertex);
if (isVisited != null && isVisited) {
    continue;
}
```

### 3.2 Old Distance Check
```java
Integer oldDistance = distances.get(toVertexId);
if (oldDistance == null || newDistance < oldDistance) {
    distances.put(toVertexId, newDistance);
    pq.insert(newDistance, toVertexId);
}
```

### 3.3 Added Check
```java
Boolean added1 = added.get(v1);
if (dist1 != null && (added1 == null || !added1)) {
    answers.add(new Entry<>(v1, dist1));
    added.put(v1, true);
}
```

---

Refer to the referencing guide on the LMS for details on what needs to go in
here. If in doubt, put your references here. Ignorance is NOT an excuse for
skipping this process.
